##4)Kortsvarspørsmål

1.  Når animated har et `protected` datamedlem vil det si at den er tilgjengelig ikke bare av den klassen, men også av de som arver denne klassen og av deres `friend` klasser. Ved at et medlem er protected i en baseklasse, kan de som arver lett gjøre forandringer på verdien til dette datamedlemet samt å kalle på det ved å kun bruke navnet på den: Eks: `t=t+3;`. Ulempen med dette er at klasser som arver lett kan "ødelegge" koden, ved at de ikke helt vet hva denne variablen gjør, og setter den til en tilstand som er uheldig ved en feiltagelse. Et annet problem som kan oppstå er om en av de som arver oppretter et objekt med samme navn som denne variablen. Det vil da være usikkert om det er den lokale variablen eller protected variablen til baseklassen det refereres til.
    
    En annen løsning vil være å gjøre den `private` og ha get- og set-metode for å lese av og å forandre verdien. Man kan da velge å ha disse metodene protected eller public om det er det som er behovet. Et tilsvarende eksempel vil da bli: `set_t(get_t()+3);`. Du ville da sluppet at arvende klasser så lett kan "ødelegge" ved en feiltagelse, og variabelnavnet vil være "ledig" for gjenbruk.
2.  Det brukes jo metoder fra fltk bibloteket i bl.a `dot` klassen. Den har selv fått ansvar for å tegne seg selv med `draw()`, hvor man da må ha `fl_pie(..)`. Man kan jo tenke seg at man kan overskrive denne metoden, men `r` har ingen `get`-metode så dermed er det bare `dot.draw()` som kan ta seg av tegningen.
3.  Man kunne kanskje hatt et namespace som het...
4.  Skulle man brukt templates på `animation_canvas` og brukt `typename T` så kunne man ha byttet ut animated med T. Du ville da kunne lagt inn hvilke som helst objecter så lenge de arver samme baseklasse. Det ville gjort koden mer generell. Du ville blitt nødt til å legge all kode inn i header-fila. Problemet med det er at en tvinger alle som bruker denne klassen til å kompilere strengt tatt mer enn nødvendig. Alternativt kunne man eksplisitt sette inn for hvilke typer kompilatoren skal kompilere for i slutten av `cpp` fila. Men dette igjen gjør koden mindre gjenbrukbar da man må inn i `cpp`-fila og legge til for alle nye typer man vil sende med.
5.  Klassen has_color burde nok hatt en virituell destruktor. Siden den har en virituell funksjon (den er abstrakt), kan det være sannsynlig at man kan komme til å ønske å bruke en `has_color` peker til å holde et objekt av "My_class" som arver has_color. Om has_color ikke har en virituell destruktor og om man har allokert minne med new i My_class, så vil man få memory leaks når man sletter denne pekeren, selv om My_class har en destruktor som tar hånd om det allokerte minnet. Fordi destruktoren i My_class aldri blir kalt. Det ville den om `has_color` hadde en virituell destruktor.

Det er heller ikke opplagt at man skal bruke red_, green_ og blue_ til å peke på de tre første bytene i color_. Man kan også løse dette ved å bruke `new` og deretter `Fl::get_color(Fl_Color i, uchar& red, uchar& green, uchar& blue)` for å sette r,g,b. Men dette vil også kreve at man har en destruktor til å destruere r,g,b.

    Jeg kunne beholdt `TintedDotFactory.cpp` og eksplisitt sagt hvilke verdier `FL_BLUE`, `FL_RED` etc i slutten av fila for å redusere kompileringstiden noe, men dette hadde gjort kode mindre anvendelig senere, da man må gå inn å legge til nye godkjente verdier. Dette blir en smaksak.
    
    Det ville vært fint å kunne implementere funksjonen `animation_finished` fra `animated` i `rocket` og `dot`, men siden den ikke var med i headerfilene turte jeg ikke gjøre det. Vi hadde jo fått streng beskjed å ikke forandre dem.
